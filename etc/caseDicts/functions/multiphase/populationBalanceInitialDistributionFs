/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  dev
     \\/     M anipulation  |
-------------------------------------------------------------------------------
Description
    Generates initial size group fractions given a distribution. Uses the
    fDefault.<phase> field file as a reference from which to construct boundary
    conditions. All boundary conditions in this file must be default
    constructable, or this will not work.

\*---------------------------------------------------------------------------*/

type            coded;
libs            ("libutilityFunctionObjects.so");

phase           <phaseName>;                           // The phase to write
                                                       // size-group fractions
                                                       // for


initialDistributionFile <initialDistributionFileName>; // The file containing
                                                       // the distribution. In
                                                       // foam format.

codeInclude
#{
    #include "stringOps.H"
    #include "Table.H"
    #include "volFields.H"
#};

codeRead
#{
    // Read the initial distribution table
    const Function1s::Table<scalar> initialDistribution
    (
        "initialDistribution",
        dimLength,
        dimless,
        dictionary
        (
            "format", "foam",
            "file", dict.lookup<fileName>("initialDistributionFile")
        )
    );

    // Read the phase properties dictionary
    const IOdictionary phasePropertiesDict
    (
        IOobject
        (
            "phaseProperties",
            mesh().time().constant(),
            mesh(),
            IOobject::MUST_READ,
            IOobject::NO_WRITE
        )
    );

    // Read the phase name
    const word phaseName = dict.lookup<word>("phase");

    // Get the diameter model dictionary
    const dictionary& diameterModelDict =
        phasePropertiesDict
       .subDict(phaseName)
       .optionalSubDict("velocityGroupCoeffs");

    // Determine the population balance name
    const word popBalName =
        diameterModelDict.lookup<word>("populationBalance");

    // Determine the index of the first size-group of this phase
    label sizeGroupi0 = 0;
    {
        const wordList phaseNames =
            phasePropertiesDict.lookup<wordList>("phases");

        forAll(phaseNames, phasei)
        {
            if (phaseNames[phasei] == phaseName) break;

            const dictionary& phaseDict =
                phasePropertiesDict.subDict(phaseNames[phasei]);

            const word phaseDiameterModelType =
                phaseDict.lookup("diameterModel");

            if (phaseDiameterModelType != "velocityGroup") continue;

            const dictionary& phaseDiameterModelDict =
                phaseDict.optionalSubDict("velocityGroupCoeffs");

            const word phasePopBalName =
                phaseDiameterModelDict.lookup<word>("populationBalance");

            if (phasePopBalName != popBalName) continue;

            const List<dictionary> phaseSizeGroupDicts
            (
                phaseDiameterModelDict.lookup("sizeGroups")
            );

            sizeGroupi0 += phaseSizeGroupDicts.size();
        }
    }

    // Load the default fraction field
    const volScalarField fDefault
    (
        IOobject
        (
            IOobject::groupName("fDefault", phaseName),
            mesh().time().name(),
            mesh(),
            IOobject::MUST_READ
        ),
        mesh()
    );

    // Read the individual size group dictionaries
    const List<dictionary> sizeGroupDicts
    (
        diameterModelDict.lookup("sizeGroups")
    );

    // Evaluate the initial distribution at the size-groups' representative
    // spherical diameters
    scalarField fs(sizeGroupDicts.size());
    forAll(sizeGroupDicts, sizeGroupi)
    {
        fs[sizeGroupi] =
            initialDistribution.value
            (
                dimensionedScalar
                (
                    "dSph",
                    dimLength,
                    sizeGroupDicts[sizeGroupi]
                ).value()
            );
    }

    // Normalise within the phase
    fs = (fs + rootVSmall)/sum(fs + rootVSmall);

    // Construct numbered fraction fields with the values set to that of the
    // evaluated distribution
    forAll(sizeGroupDicts, sizeGroupi)
    {
        volScalarField fi
        (
            IOobject
            (
                IOobject::groupName
                (
                    "f" + Foam::name(sizeGroupi + sizeGroupi0),
                    phaseName
                ),
                mesh().time().name(),
                mesh(),
                IOobject::READ_IF_PRESENT
            ),
            fDefault
        );

        fi == dimensionedScalar(dimless, fs[sizeGroupi]);

        fi.write();
    }
#};

// ************************************************************************* //
